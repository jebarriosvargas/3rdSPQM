[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "3rdSPDM",
    "section": "",
    "text": "Comentarios generales",
    "crumbs": [
      "Comentarios generales"
    ]
  },
  {
    "objectID": "1_basics.html",
    "href": "1_basics.html",
    "title": "1  Estructura cristalina (cristal)",
    "section": "",
    "text": "1.1 Red en 2D\nMostrar código\n# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import * \n\n# Definimos la magnitud de los vectores, a1 y a2\na1 = 1.0\na2 = 1.0\n# Definimos el vector vec_a1\nvec_a1 = array([       a1,         0])\n# Definimos el vector vec_a2 con una rotación de un ángulo θ\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4] \n# tanto para n1 como n2\nn1,n2 = meshgrid ( arange( -4, 5 ), arange( -4, 5 ) )\n# Con el fin de realizar las diferentes combinaciones lineales nos será \n# útil tener los coeficiente como un arreglo en una dimensión\nn1 = n1.flatten()\nn2 = n2.flatten()\n# Colocamos los vectores en una matriz, donde cada renglón es un vector\nA = array( [vec_a1,vec_a2] )\n# Colocamos los coeficientes en una matriz\ncoefs = column_stack((n1,n2))\n# Obtenemos los puntos de la red al multiplicar ambas matrices\nred = dot( coefs,A )\n\n# Graficamos \n# Definimos una figura -&gt; fig y sus ejes -&gt; ax\nfig,ax = plt.subplots(figsize=((6,6)))\n\n# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\nax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n\n# Graficamos los vectores de red\nax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\nax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n\n# Colocamos el cuadro de leyenda\nax.legend()\n\nax.set_aspect('equal')\n\n# Mostramos la gráfica\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1.1: Ejemplo de red bidimensional\nHay dos formas de identificar la celda primitiva.\nMostrar código\nfrom pylab import *\n\ndef GraficadeRedCell(vec_a1,vec_a2,polyx,polyy):\n    n1,n2 = meshgrid ( arange( -12, 13 ), arange( -12,13 ) )\n    n1 = n1.flatten()\n    n2 = n2.flatten()\n    A = array( [vec_a1,vec_a2] )\n    coefs = column_stack((n1,n2))\n    red = dot( coefs,A )\n\n    a1 = sqrt(dot(vec_a1,vec_a1))\n    a2 = sqrt(dot(vec_a2,vec_a2))\n\n    fig,ax = plt.subplots(figsize=((6,6)))\n    ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n    ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n    ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n\n\n    ax.fill(polyx,polyy,alpha=0.5,color=\"#50c878\")\n\n    ax.legend()\n    ax.set_xlim(-6.4,6.4)\n    ax.set_ylim(-3.4,3.4)\n    ax.set_aspect('equal')\n    plt.show()\n    return \n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\npolyx = [0,vec_a1[0],vec_a1[0]+vec_a2[0],vec_a2[0],0]\npolyy = [0,vec_a1[1],vec_a1[1]+vec_a2[1],vec_a2[1],0]\n\nGraficadeRedCell(vec_a1,vec_a2,polyx,polyy)\n\n\n\n\n\n\n\n\nFigure 1.2: Ejemplo de red bidimensional\nMostrar código\ndef FindInterection2D(v,w):\n    AA = np.array([v[0:2],w[0:2]])\n    bb = 0.5*np.array( [np.dot(v,v),np.dot(w,w)] )\n    return np.linalg.solve(AA, bb)\n\ndef BuildWignerSeitz(vec_a1,vec_a2):\n    puntosall = []\n    for n in arange(-1,2):\n        for m in arange(-1,2):\n            w = n*vec_a1+m*vec_a2\n            if (m!=0):\n                xp = FindInterection2D( vec_a1,w)\n                xn = FindInterection2D(-vec_a1,w)\n            if (n!=0):\n                yp = FindInterection2D( vec_a2,w)\n                yn = FindInterection2D(-vec_a2,w)\n            puntosall.append(xp)\n            puntosall.append(yp)\n            puntosall.append(xn)\n            puntosall.append(yn)\n    puntosall = array(puntosall).T\n\n    # Selecciona sólo los que están a la mínima distancia\n    dist    = sum(puntosall.T*puntosall.T,axis=1)\n    mindist = min(dist)\n    ϵ       = 1e-4\n    logical = dist&lt;(mindist+ϵ)\n    WignerSeitz = puntosall[:,logical]\n\n    # Quita los puntos repetidos (sólo funciona en 2D)\n    n   = 0\n    z   = WignerSeitz[0]+WignerSeitz[1]*1J\n    ang = angle(z)\n    while (n&lt;len(z)):\n        l_ind    = ones(len(z),dtype=bool)\n        l_ind[n] = False\n        \n        arrlog = logical_and( abs(ang-ang[n])&lt;ϵ, l_ind)\n\n        arrlog = array( arrlog==False)\n\n        z   = array(z[arrlog])\n        ang = angle(z)\n        n += 1\n        \n    indSort = argsort(ang)\n\n    WignerSeitz = array([real(z[indSort]),imag(z[indSort])])\n    return WignerSeitz\n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\nWignerSeitz = BuildWignerSeitz(vec_a1,vec_a2)\n\nGraficadeRedCell(vec_a1,vec_a2,WignerSeitz[0],WignerSeitz[1])\n\n\n\n\n\n\n\n\nFigure 1.3: Ejemplo de red bidimensional",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Estructura cristalina (cristal)</span>"
    ]
  },
  {
    "objectID": "1_basics.html#cristal-estructura-cristalina",
    "href": "1_basics.html#cristal-estructura-cristalina",
    "title": "1  Conceptos básicos",
    "section": "",
    "text": "Vanderbilt, David. 2018. Berry Phases in Electronic Structure Theory: Electric Polarization, Orbital Magnetization and Topological Insulators. Cambridge University Press.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Conceptos básicos</span>"
    ]
  },
  {
    "objectID": "2_grafeno.html",
    "href": "2_grafeno.html",
    "title": "3  Grafeno",
    "section": "",
    "text": "3.1 Supercelda de grafeno\nCuaderno de trabajo: Colab Google.\nCuaderno de trabajo de la sesión del lunes 5 de noviembre Google Colab\nMostrar código\nmpl.rcParams['figure.figsize'] = (2.5,2.5)\n\n# Graphene supercell (4 atoms)\n\ngraphene_sc = graphene.make_supercell([[1, 0], [-1, 2]])\n\n(fig,ax) = graphene_sc.visualize(0,1)\nax.set_title(\"Graphene (supercell)\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nfig.tight_layout()\n\n\n\n\n\n\n\n\nFigure 3.3: Supercelda de grafeno",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Grafeno</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Vanderbilt, David. 2018. Berry Phases in Electronic Structure\nTheory: Electric Polarization, Orbital Magnetization and Topological\nInsulators. Cambridge University Press.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "1_basics.html#estructura-cristalina-cristal",
    "href": "1_basics.html#estructura-cristalina-cristal",
    "title": "1  Conceptos básicos",
    "section": "",
    "text": "Estaremos interesados en arreglos de átomos con simetría traslacional que llamaremos estructuras periódicas o estructuras cristalinas (de forma breve también los llamaremos cristales). Las estructuras periódicas se caracterizan por la combinación de una red y un decorado.\n\n\n\n\n\n\n\nNoteRed (definición)\n\n\n\n\n\nUna red es el conjunto infinito de puntos definidos por la suma con coeficientes enteros de un conjunto de vectores de red linealmente independientes (a lo largo del curso pensaremos en ejemplos en dos dimension).\n\\[\n\\text{En 2D: }\\quad \\bigg\\{ \\vec{R}_{(n1,n2)} = n_1\\vec{a}_1 +n_2\\vec{a}_2 \\;\\bigg|\\; n_1,n_2 \\in \\mathbb{Z}\\bigg\\}\n\\]\n\n\n\n\n\n\nEn el curso consideraremos únicamente ejemplos en dos dimensiones sólo por cuestiones visuales de los resultados.\n\n\n1.1.1 Red en 2D\n\n\nMostrar código\n# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import * \n\n# Definimos la magnitud de los vectores, a1 y a2\na1 = 1.0\na2 = 1.0\n# Definimos el vector vec_a1\nvec_a1 = array([       a1,         0])\n# Definimos el vector vec_a2 con una rotación de un ángulo θ\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4] \n# tanto para n1 como n2\nn1,n2 = meshgrid ( arange( -4, 5 ), arange( -4, 5 ) )\n# Con el fin de realizar las diferentes combinaciones lineales nos será \n# útil tener los coeficiente como un arreglo en una dimensión\nn1 = n1.flatten()\nn2 = n2.flatten()\n# Colocamos los vectores en una matriz, donde cada renglón es un vector\nA = array( [vec_a1,vec_a2] )\n# Colocamos los coeficientes en una matriz\ncoefs = column_stack((n1,n2))\n# Obtenemos los puntos de la red al multiplicar ambas matrices\nred = dot( coefs,A )\n\n# Graficamos \n# Definimos una figura -&gt; fig y sus ejes -&gt; ax\nfig,ax = plt.subplots(figsize=((6,6)))\n\n# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\nax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n\n# Graficamos los vectores de red\nax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\nax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n\n# Colocamos el cuadro de leyenda\nax.legend()\n\nax.set_aspect('equal')\n\n# Mostramos la gráfica\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1.1: Ejemplo de red bidimensional\n\n\n\n\n\n\n\n\n\n\n\nNoteCelda primitiva (definición)\n\n\n\n\n\nEs la celda unitaria que contiene un punto de la red.\n\n\n\nHay dos formas de identificar la celda primitiva.\n\n\n\n\n\n\nTipA partir de los vectores de red\n\n\n\n\n\n\nEn 2D, la celda primitiva es el paralelogramo formado por los vectores de la red. En 3D, la celda primitiva es el paralelepipedo formado por los vectores de la red.\n\n\n\n\n\n\nMostrar código\nfrom pylab import *\n\ndef GraficadeRedCell(vec_a1,vec_a2,polyx,polyy):\n    n1,n2 = meshgrid ( arange( -12, 13 ), arange( -12,13 ) )\n    n1 = n1.flatten()\n    n2 = n2.flatten()\n    A = array( [vec_a1,vec_a2] )\n    coefs = column_stack((n1,n2))\n    red = dot( coefs,A )\n\n    a1 = sqrt(dot(vec_a1,vec_a1))\n    a2 = sqrt(dot(vec_a2,vec_a2))\n\n    fig,ax = plt.subplots(figsize=((6,6)))\n    ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n    ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n    ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n\n\n    ax.fill(polyx,polyy,alpha=0.5,color=\"#50c878\")\n\n    ax.legend()\n    ax.set_xlim(-6.4,6.4)\n    ax.set_ylim(-3.4,3.4)\n    ax.set_aspect('equal')\n    plt.show()\n    return \n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\npolyx = [0,vec_a1[0],vec_a1[0]+vec_a2[0],vec_a2[0],0]\npolyy = [0,vec_a1[1],vec_a1[1]+vec_a2[1],vec_a2[1],0]\n\nGraficadeRedCell(vec_a1,vec_a2,polyx,polyy)\n\n\n\n\n\n\n\n\nFigure 1.2: Ejemplo de red bidimensional\n\n\n\n\n\n\n\n\n\n\n\nTipConstrucción de Wigner-Seitz\n\n\n\n\n\n\nEn 2D, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza su mediatriz (una línea perpendicular al segmento que pase por el punto medio). El área más pequeña encerrada por las mediatrices es la celda primitiva de Wigner-Seitz. En 3D, también, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza un plano perpendicular a cada segmento que pase por el punto medio. El volumen más pequeño encerrado por los planos es la celda primitiva de Wigner-Seitz.\n\n\n\n\n\n\nMostrar código\ndef FindInterection2D(v,w):\n    AA = np.array([v[0:2],w[0:2]])\n    bb = 0.5*np.array( [np.dot(v,v),np.dot(w,w)] )\n    return np.linalg.solve(AA, bb)\n\ndef BuildWignerSeitz(vec_a1,vec_a2):\n    puntosall = []\n    for n in arange(-1,2):\n        for m in arange(-1,2):\n            w = n*vec_a1+m*vec_a2\n            if (m!=0):\n                xp = FindInterection2D( vec_a1,w)\n                xn = FindInterection2D(-vec_a1,w)\n            if (n!=0):\n                yp = FindInterection2D( vec_a2,w)\n                yn = FindInterection2D(-vec_a2,w)\n            puntosall.append(xp)\n            puntosall.append(yp)\n            puntosall.append(xn)\n            puntosall.append(yn)\n    puntosall = array(puntosall).T\n\n    # Selecciona sólo los que están a la mínima distancia\n    dist    = sum(puntosall.T*puntosall.T,axis=1)\n    mindist = min(dist)\n    ϵ       = 1e-4\n    logical = dist&lt;(mindist+ϵ)\n    WignerSeitz = puntosall[:,logical]\n\n    # Quita los puntos repetidos (sólo funciona en 2D)\n    n   = 0\n    z   = WignerSeitz[0]+WignerSeitz[1]*1J\n    ang = angle(z)\n    while (n&lt;len(z)):\n        l_ind    = ones(len(z),dtype=bool)\n        l_ind[n] = False\n        \n        arrlog = logical_and( abs(ang-ang[n])&lt;ϵ, l_ind)\n\n        arrlog = array( arrlog==False)\n\n        z   = array(z[arrlog])\n        ang = angle(z)\n        n += 1\n        \n    indSort = argsort(ang)\n\n    WignerSeitz = array([real(z[indSort]),imag(z[indSort])])\n    return WignerSeitz\n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\nWignerSeitz = BuildWignerSeitz(vec_a1,vec_a2)\n\nGraficadeRedCell(vec_a1,vec_a2,WignerSeitz[0],WignerSeitz[1])\n\n\n\n\n\n\n\n\nFigure 1.3: Ejemplo de red bidimensional\n\n\n\n\n\n\n\n1.1.2 Decorado (Motif)\n\n\n\n\n\n\nNoteDecorado (definición)\n\n\n\n\n\n\nLa descripción de los objetos en una celda unitaria respecto a los puntos de referencia en una celda se conocen como decorado (motif).\n\n\n\n\n\n\n\n\n\n\nNoteEstructura cristalina\n\n\n\n\n\nUna estructura cristalina se compone de una red y un decorado.\n\n\n\nEjemplo: Panal de abeja\n\\[\n\\text{sitio 1: }\\frac{1}{3}\\vec{a}_1 + \\frac{1}{3}\\vec{a}_2\\quad\n\\text{sitio 2: }\\frac{2}{3}\\vec{a}_1 + \\frac{2}{3}\\vec{a}_2\n\\]\ndonde\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(60^\\circ)\\\\\\sin(60^\\circ)\\end{array} \\right]\n\\]\n\n\nMostrar código\nfrom pylab import *\ndef GenerarRed(n_1,n_2,a_1,a_2):\n  # -- Desarrollo técnico --\n  # Malla de enteros\n  N1,N2 = meshgrid(n_1,n_2)\n  # Cambiar a columnas\n  N1    = N1.flatten()\n  N2    = N2.flatten()\n  N1y2 = column_stack((N1,N2))\n  # Agrupar los vectores de red\n  avec = [a_1,a_2]\n\n  # Tomar todas las combinaciones\n  Rx,Ry = dot( N1y2,avec ).T\n  return Rx,Ry\n\na_1 = [1,0]\na_2 = [1/2,sqrt(3)/2]\n\nn_1 = arange(-4,4)\nn_2 = arange(-4,4)\n\nRx,Ry = GenerarRed(n_1,n_2,a_1,a_2)\n\nsitio1x = Rx + (1/3)*( a_1[0]+a_2[0] )\nsitio1y = Ry + (1/3)*( a_1[1]+a_2[1] )\n\nsitio2x = Rx + (2/3)*( a_1[0]+a_2[0] )\nsitio2y = Ry + (2/3)*( a_1[1]+a_2[1] )\n\nimport plotly.graph_objects as go\n\nData = [go.Scatter(x=sitio1x,y=sitio1y,mode='markers',showlegend=False),\n        go.Scatter(x=sitio2x,y=sitio2y,mode='markers',showlegend=False)]\n\nfig = go.Figure(data=Data)\nfig.update_xaxes(range=[-2,2])\nfig.update_yaxes(range=[-2,2])\nfig.update_layout(width=400, height=400)\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 1.4: Ejemplo de estructura cristalina de panal de abeja.\n\n\n\n\nVer Vanderbilt (2018) como referencia.\n\n\n\n\nVanderbilt, David. 2018. Berry Phases in Electronic Structure Theory: Electric Polarization, Orbital Magnetization and Topological Insulators. Cambridge University Press.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Conceptos básicos</span>"
    ]
  },
  {
    "objectID": "1_basics.html#en-2d",
    "href": "1_basics.html#en-2d",
    "title": "1  Conceptos básicos",
    "section": "1.2 En 2D",
    "text": "1.2 En 2D\n\n\nMostrar código\n# En el ambiente cargamos las opciones más comúnes de numpy, scipy y matplotlib\nfrom pylab import * \n\n# Definimos la magnitud de los vectores, a1 y a2\na1 = 1.0\na2 = 1.0\n# Definimos el vector vec_a1\nvec_a1 = array([       a1,         0])\n# Definimos el vector vec_a2 con una rotación de un ángulo θ\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n# Tomamos un subconjunto del conjunto de enteros [-4,-3,-2,-1,0,1,2,3,4] \n# tanto para n1 como n2\nn1,n2 = meshgrid ( arange( -4, 5 ), arange( -4, 5 ) )\n# Con el fin de realizar las diferentes combinaciones lineales nos será \n# útil tener los coeficiente como un arreglo en una dimensión\nn1 = n1.flatten()\nn2 = n2.flatten()\n# Colocamos los vectores en una matriz, donde cada renglón es un vector\nA = array( [vec_a1,vec_a2] )\n# Colocamos los coeficientes en una matriz\ncoefs = column_stack((n1,n2))\n# Obtenemos los puntos de la red al multiplicar ambas matrices\nred = dot( coefs,A )\n\n# Graficamos \n# Definimos una figura -&gt; fig y sus ejes -&gt; ax\nfig,ax = plt.subplots(figsize=((6,6)))\n\n# Graficamos con puntos los puntos de la red en un sistema de coordenadas cartesiano. \n# En el eje x colocamos los puntos de la red y en el eje y asignamos cero.\n# ax.scatter( [coordenadas: x] , [coordenadas: y], label=\"Etiqueta que identifica los datos\")\nax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n# Escribimos ax.scatter ya que se grafican los puntos (scatter) en los ejes (ax).\n\n# Graficamos los vectores de red\nax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\nax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n\n# Colocamos el cuadro de leyenda\nax.legend()\n\nax.set_aspect('equal')\n\n# Mostramos la gráfica\nplt.show()\n\n\n\n\n\n\n\n\nFigure 1.1: Ejemplo de red bidimensional\n\n\n\n\n\n\n\n\n\n\n\nNoteCelda primitiva (definición)\n\n\n\n\n\nEs la celda unitaria que contiene un punto de la red.\n\n\n\nHay dos formas de identificar la celda primitiva.\n\n\n\n\n\n\nTipA partir de los vectores de red\n\n\n\n\n\n\nEn 2D, la celda primitiva es el paralelogramo formado por los vectores de la red. En 3D, la celda primitiva es el paralelepipedo formado por los vectores de la red.\n\n\n\n\n\n\nMostrar código\nfrom pylab import *\n\ndef GraficadeRedCell(vec_a1,vec_a2,polyx,polyy):\n    n1,n2 = meshgrid ( arange( -12, 13 ), arange( -12,13 ) )\n    n1 = n1.flatten()\n    n2 = n2.flatten()\n    A = array( [vec_a1,vec_a2] )\n    coefs = column_stack((n1,n2))\n    red = dot( coefs,A )\n\n    a1 = sqrt(dot(vec_a1,vec_a1))\n    a2 = sqrt(dot(vec_a2,vec_a2))\n\n    fig,ax = plt.subplots(figsize=((6,6)))\n    ax.scatter(red.T[0], red.T[1], label=f\"$a_1={a1:.2f}, a_2={a2:.2f}, θ={rad2deg(θ):.1f}$\")\n    ax.arrow(0,0,vec_a1[0],vec_a1[1],width=0.08,lw=0,label=\"vec $a_1$\",color=\"red\",length_includes_head=True)\n    ax.arrow(0,0,vec_a2[0],vec_a2[1],width=0.08,lw=0,label=\"vec $a_2$\",color=\"blue\",length_includes_head=True)\n\n\n    ax.fill(polyx,polyy,alpha=0.5,color=\"#50c878\")\n\n    ax.legend()\n    ax.set_xlim(-6.4,6.4)\n    ax.set_ylim(-3.4,3.4)\n    ax.set_aspect('equal')\n    plt.show()\n    return \n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\npolyx = [0,vec_a1[0],vec_a1[0]+vec_a2[0],vec_a2[0],0]\npolyy = [0,vec_a1[1],vec_a1[1]+vec_a2[1],vec_a2[1],0]\n\nGraficadeRedCell(vec_a1,vec_a2,polyx,polyy)\n\n\n\n\n\n\n\n\nFigure 1.2: Ejemplo de red bidimensional\n\n\n\n\n\n\n\n\n\n\n\nTipConstrucción de Wigner-Seitz\n\n\n\n\n\n\nEn 2D, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza su mediatriz (una línea perpendicular al segmento que pase por el punto medio). El área más pequeña encerrada por las mediatrices es la celda primitiva de Wigner-Seitz. En 3D, también, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza un plano perpendicular a cada segmento que pase por el punto medio. El volumen más pequeño encerrado por los planos es la celda primitiva de Wigner-Seitz.\n\n\n\n\n\n\nMostrar código\ndef FindInterection2D(v,w):\n    AA = np.array([v[0:2],w[0:2]])\n    bb = 0.5*np.array( [np.dot(v,v),np.dot(w,w)] )\n    return np.linalg.solve(AA, bb)\n\ndef BuildWignerSeitz(vec_a1,vec_a2):\n    puntosall = []\n    for n in arange(-1,2):\n        for m in arange(-1,2):\n            w = n*vec_a1+m*vec_a2\n            if (m!=0):\n                xp = FindInterection2D( vec_a1,w)\n                xn = FindInterection2D(-vec_a1,w)\n            if (n!=0):\n                yp = FindInterection2D( vec_a2,w)\n                yn = FindInterection2D(-vec_a2,w)\n            puntosall.append(xp)\n            puntosall.append(yp)\n            puntosall.append(xn)\n            puntosall.append(yn)\n    puntosall = array(puntosall).T\n\n    # Selecciona sólo los que están a la mínima distancia\n    dist    = sum(puntosall.T*puntosall.T,axis=1)\n    mindist = min(dist)\n    ϵ       = 1e-4\n    logical = dist&lt;(mindist+ϵ)\n    WignerSeitz = puntosall[:,logical]\n\n    # Quita los puntos repetidos (sólo funciona en 2D)\n    n   = 0\n    z   = WignerSeitz[0]+WignerSeitz[1]*1J\n    ang = angle(z)\n    while (n&lt;len(z)):\n        l_ind    = ones(len(z),dtype=bool)\n        l_ind[n] = False\n        \n        arrlog = logical_and( abs(ang-ang[n])&lt;ϵ, l_ind)\n\n        arrlog = array( arrlog==False)\n\n        z   = array(z[arrlog])\n        ang = angle(z)\n        n += 1\n        \n    indSort = argsort(ang)\n\n    WignerSeitz = array([real(z[indSort]),imag(z[indSort])])\n    return WignerSeitz\n\na1 = 1.0\na2 = 1.0\nvec_a1 = array([       a1,         0])\nθ = radians(60)\nvec_a2 = array([a2*cos(θ), a2*sin(θ)])\n\nWignerSeitz = BuildWignerSeitz(vec_a1,vec_a2)\n\nGraficadeRedCell(vec_a1,vec_a2,WignerSeitz[0],WignerSeitz[1])\n\n\n\n\n\n\n\n\nFigure 1.3: Ejemplo de red bidimensional",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Conceptos básicos</span>"
    ]
  },
  {
    "objectID": "index.html#requerimientos",
    "href": "index.html#requerimientos",
    "title": "3rdSPDM",
    "section": "Requerimientos",
    "text": "Requerimientos\n\nEn la parte práctica del curso utilizaremos el servicio de https://colab.research.google.com/ por lo que se requiere una cuenta asociada de Google y conexión a internet.",
    "crumbs": [
      "Comentarios generales"
    ]
  },
  {
    "objectID": "1_tbh.html",
    "href": "1_tbh.html",
    "title": "2  Aproximación de amarre fuerte",
    "section": "",
    "text": "2.1 Sistema finito\nLas expresiones a continuación son un resumen de la sección 2.2 Tight-Binding Model Hamiltonians de la referencia Vanderbilt (2018).\nEl Hamiltoniano de un conjunto de átomos es,\n\\[\\begin{align}\nH = T_{\\rm e} + T_{\\rm n} + V_{\\rm e-e} + V_{\\rm n-e} + V_{\\rm n-n}\n\\end{align}\\]\nAproximación de Born-Oppenheimer,\n\\[\\begin{align}\nH_{\\rm elec} = T_{\\rm e} + V_{\\rm n-e} + V_{\\rm e-e}\n\\end{align}\\]\nTípicamente se define,\n\\[\\begin{align}\nV_{\\rm ext} = \\sum_{\\rm I} \\frac{1}{4\\pi\\epsilon_0}\\frac{e^2 Z_I}{|\\vec{r}-\\vec{R}_I|}\n\\end{align}\\]\nCon la cual se escribe,\n\\[\\begin{align}\nH_{\\rm elec} = \\sum_{i} \\bigg[ \\frac{p_i^2}{2m} + V_{\\rm ext}(\\vec{r}_i) \\bigg] + \\frac{1}{2}\\sum_{ij} \\frac{1}{4\\pi\\epsilon_0}\\frac{e^2}{|\\vec{r}_i-\\vec{r}_j|}\n\\end{align}\\]\nEsta ecuación es imposible de resolver cuando el número de electrones es muy grande. La primera aproximación fuerte es que consideraremos \\(V_{\\rm e-e}\\) despreciable.\nCorazón: Simplificaremos el problema con el fin de proveer un entendimiento de la física y química del cristal.\nFrecuentemente, elegimos una base de orbitales tipo atómicos \\(\\varphi_j\\) localizados en los diferentes sitios \\(j\\). Podemos escribir nuestro eigenestado de prueba de la forma\n\\[\\begin{align}\n\\psi_n(\\vec{r}) = \\sum_j C_{nj}\\varphi_j(\\vec{r}-\\vec{r}_j)\n\\end{align}\\]\ndonde los coeficientes de la expansión \\(C_{nj}\\) del \\(n\\)-ésimo eigenestado del orbital \\(j\\)-ésimo están por determinarse. Por tanto, las soluciones se encuentran resolviendo la ecuación matricial,\n\\[\\begin{align}\n\\big( \\mathbf{H} - E_n \\mathbf{S}) \\mathbf{C}_n = 0\n\\end{align}\\]\ndonde \\(\\mathbf{H}\\) y \\(\\mathbf{S}\\) son matrices,\n\\[\\begin{align}\nH_{ij} &= \\langle \\varphi_i| H_{\\rm elec} |\\varphi_j\\rangle \\\\\nS_{ij} &= \\langle \\varphi_i| \\varphi_j\\rangle\n\\end{align}\\]\n\\(\\mathbf{C}_n\\) es un vector columna de coeficientes \\(C_{nj}\\).\n\\(H_{ii}\\): energías de sitio (on-site) (elementos en la diagonal)\n\\(H_{ij}\\): elementos de salto (hopping) (fuera de la diagonal)\n\\(S_{ij}\\): matriz de traslape\nOtra aproximación cuestionable, \\(S_{ij}\\) es aproximadamente diagonal.\n\\[\\begin{align}\nS_{ij} &= \\langle \\varphi_i| \\varphi_j\\rangle \\approx \\delta_{i,j}\n\\end{align}\\]\nes decir los orbitales atómicos localizados en sitios diferentes son una base ortonormal.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aproximación de amarre fuerte</span>"
    ]
  },
  {
    "objectID": "1_basics.html#red-en-2d",
    "href": "1_basics.html#red-en-2d",
    "title": "1  Estructura cristalina (cristal)",
    "section": "",
    "text": "NoteCelda primitiva (definición)\n\n\n\n\n\nEs la celda unitaria que contiene un punto de la red.\n\n\n\n\n\n\n\n\n\n\nTipA partir de los vectores de red\n\n\n\n\n\n\nEn 2D, la celda primitiva es el paralelogramo formado por los vectores de la red. En 3D, la celda primitiva es el paralelepipedo formado por los vectores de la red.\n\n\n\n\n\n\n\n\n\n\n\nTipConstrucción de Wigner-Seitz\n\n\n\n\n\n\nEn 2D, elegimos un punto de la red y dibujamos los segmentos de recta que unen el punto elegido con los puntos vecinos. Para cada segmento se traza su mediatriz (una línea perpendicular al segmento que pase por el punto medio). El área más pequeña encerrada por las mediatrices es la celda primitiva de Wigner-Seitz.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Estructura cristalina (cristal)</span>"
    ]
  },
  {
    "objectID": "1_basics.html#decorado-motif",
    "href": "1_basics.html#decorado-motif",
    "title": "1  Estructura cristalina (cristal)",
    "section": "1.2 Decorado (Motif)",
    "text": "1.2 Decorado (Motif)\n\n\n\n\n\n\nNoteDecorado (definición)\n\n\n\n\n\n\nLa descripción de los objetos en una celda unitaria respecto a los puntos de referencia en una celda se conocen como decorado (motif).\n\n\n\n\n\n\n\n\n\n\nNoteEstructura cristalina\n\n\n\n\n\nUna estructura cristalina se compone de una red y un decorado.\n\n\n\nEjemplo: Panal de abeja\n\\[\n\\text{sitio 1: }\\frac{1}{3}\\vec{a}_1 + \\frac{1}{3}\\vec{a}_2\\quad\n\\text{sitio 2: }\\frac{2}{3}\\vec{a}_1 + \\frac{2}{3}\\vec{a}_2\n\\]\ndonde\n\\[\n\\vec{a}_1=\\left[\\begin{array}{c}1\\\\0\\end{array} \\right] \\quad \\text{y} \\quad \\vec{a}_2=\\left[\\begin{array}{c}\\cos(60^\\circ)\\\\\\sin(60^\\circ)\\end{array} \\right]\n\\]\n\n\nMostrar código\nfrom pylab import *\ndef GenerarRed(n_1,n_2,a_1,a_2):\n  # -- Desarrollo técnico --\n  # Malla de enteros\n  N1,N2 = meshgrid(n_1,n_2)\n  # Cambiar a columnas\n  N1    = N1.flatten()\n  N2    = N2.flatten()\n  N1y2 = column_stack((N1,N2))\n  # Agrupar los vectores de red\n  avec = [a_1,a_2]\n\n  # Tomar todas las combinaciones\n  Rx,Ry = dot( N1y2,avec ).T\n  return Rx,Ry\n\na_1 = [1,0]\na_2 = [1/2,sqrt(3)/2]\n\nn_1 = arange(-4,4)\nn_2 = arange(-4,4)\n\nRx,Ry = GenerarRed(n_1,n_2,a_1,a_2)\n\nsitio1x = Rx + (1/3)*( a_1[0]+a_2[0] )\nsitio1y = Ry + (1/3)*( a_1[1]+a_2[1] )\n\nsitio2x = Rx + (2/3)*( a_1[0]+a_2[0] )\nsitio2y = Ry + (2/3)*( a_1[1]+a_2[1] )\n\nimport plotly.graph_objects as go\n\nData = [go.Scatter(x=sitio1x,y=sitio1y,mode='markers',showlegend=False),\n        go.Scatter(x=sitio2x,y=sitio2y,mode='markers',showlegend=False)]\n\nfig = go.Figure(data=Data)\nfig.update_xaxes(range=[-2,2])\nfig.update_yaxes(range=[-2,2])\nfig.update_layout(width=400, height=400)\nfig.show()\n\n\n\n\n                            \n                                            \n\n\nFigure 1.4: Ejemplo de estructura cristalina de panal de abeja.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Estructura cristalina (cristal)</span>"
    ]
  },
  {
    "objectID": "1_tbh.html#sistema-extendido-cristal",
    "href": "1_tbh.html#sistema-extendido-cristal",
    "title": "2  Aproximación de amarre fuerte",
    "section": "2.2 Sistema extendido (cristal)",
    "text": "2.2 Sistema extendido (cristal)\nEn los sistemas extendidos los orbitales base tienen una etiqueta más que corresponde al punto de red de la celda unitaria donde se encuentran dichos orbitales,\n\\[\\begin{align}\n\\phi_{\\vec{R},j} = \\varphi_j(\\vec{r}-\\vec{R}-\\tau_j)\n\\end{align}\\]\ndonde \\(\\tau_j\\) es la posición del orbital relativa al vector de red \\(\\vec{R}\\). Supondrems de entrada la ortonormalidad,\n\\[\\begin{align}\n\\langle \\phi_{\\vec{R},i} | \\phi_{\\vec{R}',j} \\rangle =\\delta_{\\vec{R},\\vec{R}'}\\delta_{i,j}\n\\end{align}\\]\nLos elementos de matriz del Hamiltoniano están dados por,\n\\[\\begin{align}\n\\langle \\phi_{\\vec{R}',i} | H_{\\rm elec} |\\phi_{\\vec{R}'+\\vec{R},j} \\rangle &= \\int d\\vec{r} \\bigg( \\phi_{\\vec{R}',i}^*(\\vec{r}) H_{\\rm elec} \\phi_{\\vec{R}'+\\vec{R},j}(\\vec{r}) \\bigg) \\\\\n&= \\langle \\phi_{\\vec{0},i} | H_{\\rm elec} |\\phi_{\\vec{R},j} \\rangle = H_{ij}(\\vec{R})\n\\end{align}\\]\nDonde el último paso lo obtenemos por la simetría de traslación o equivalentemente al considerar \\(\\vec{R}'\\) el origen, \\(\\vec{R}'=\\vec{0}\\).\nIntroducimos la base tipo Bloch y calculamos los elementos de matriz,\n\n2.2.1 Convención I\n\\[\\begin{align}\n|\\chi_j^\\vec{k}\\rangle = \\sum_{\\vec{R}} e^{{\\rm i} \\vec{k}\\cdot (\\vec{R}+\\tau_j)}|\\phi_{\\vec{R},j}\\rangle\n\\end{align}\\]\n\\[\\begin{align}\nH_{ij}^{\\vec{k}} = \\langle \\chi_i^\\vec{k}|H_{\\rm elec}|\\chi_j^\\vec{k}\\rangle = \\sum_{\\vec{R}} e^{{\\rm i} \\vec{k}\\cdot (\\vec{R}+\\tau_j-\\tau_i)} H_{ij}(\\vec{R})\n\\end{align}\\]\nLa ecuación de eigenvalores a resolver es,\n\\[\\begin{align}\nH_{\\vec{k}} \\cdot C_{n\\vec{k}} = E_{n\\vec{k}} C_{n\\vec{k}}\n\\end{align}\\]\n\n\n2.2.2 Convención II\n\\[\\begin{align}\n|\\tilde{\\chi}_j^\\vec{k}\\rangle = \\sum_{\\vec{R}} e^{{\\rm i}\\vec{k}\\cdot \\vec{R}}|\\phi_{\\vec{R},j}\\rangle\n\\end{align}\\]\n\\[\\begin{align}\n\\tilde{H}_{ij}^{\\vec{k}} = \\langle \\tilde{\\chi}_i^\\vec{k}|H_{\\rm elec}|\\tilde{\\chi}_j^\\vec{k}\\rangle = \\sum_{\\vec{R}} e^{{\\rm i} \\vec{k}\\cdot \\vec{R}} H_{ij}(\\vec{R})\n\\end{align}\\]\nLa ecuación de eigenvalores a resolver es,\n\\[\\begin{align}\n\\tilde{H}_{\\vec{k}} \\cdot \\tilde{C}_{n\\vec{k}} = E_{n\\vec{k}} \\tilde{C}_{n\\vec{k}}\n\\end{align}\\]\n\n\n\n\n\n\nNoteRelación entre ambas convenciones\n\n\n\n\n\n\\[\\begin{align}\n\\tilde{H}_{ij}^\\vec{K} = e^{{\\rm i} e^{{\\rm i} \\vec{k} \\cdot (\\tau_i-\\tau_j)}} H_{ij}^{\\vec{k}}\n\\end{align}\\]\ny los coeficientes\n\\[\\begin{align}\n\\tilde{C}_j^{n\\vec{k}} = e^{{\\rm i} \\vec{k}\\cdot \\tau_j} C_{j}^{n\\vec{k}}\n\\end{align}\\]\nLas dos convenciones escencialmente están relacionadas por una rotación unitaria.\n\n\n\n\n\n\n\nVanderbilt, David. 2018. Berry Phases in Electronic Structure Theory: Electric Polarization, Orbital Magnetization and Topological Insulators. Cambridge University Press.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Aproximación de amarre fuerte</span>"
    ]
  },
  {
    "objectID": "3_haldane.html",
    "href": "3_haldane.html",
    "title": "4  Modelo de Haldane",
    "section": "",
    "text": "4.1 Estructura de bandas del bulto\nCuaderno de trabajo: Colab Google\nReferencia: Phys. Rev. Lett. 61, 2015 – Published 31 October, 1988 DOI: https://doi.org/10.1103/PhysRevLett.61.2015\nMostrar código\nkpoints = [ [0.0, 0.0], [1./3., 2./3.], [0.5, 0.5],[2/3,1/3],[0,0] ] # Path in k-space\nklabels = [ r\"$\\Gamma$\",     r\"$K$\",         r\"$M$\", r\"K'\" ,  r\"$\\Gamma$\"  ]\n(k_vec,k_dist,k_node) = haldane.k_path(kpoints, 100,report=False)\nevals   = haldane.solve_all(k_vec) # Solve model on k-path\nfig, ax = plt.subplots(figsize=(4,4))            # Plot bandstructure\nax.plot(k_dist, evals[0,:], c='k') \nax.plot(k_dist, evals[1,:], c='k')\nax.set_xticks(k_node)\nax.set_xticklabels(klabels)\nax.set_xlim(k_node[0],k_node[-1])\nax.set_ylabel(\"Ek\");",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Modelo de Haldane</span>"
    ]
  },
  {
    "objectID": "1_basics.html#red-recíproca-y-primera-zona-de-brillouin",
    "href": "1_basics.html#red-recíproca-y-primera-zona-de-brillouin",
    "title": "1  Estructura cristalina (cristal)",
    "section": "1.3 Red recíproca y primera zona de Brillouin",
    "text": "1.3 Red recíproca y primera zona de Brillouin\n\n\n\n\n\n\nNoteRed recíproca\n\n\n\n\n\nUn punto de la red recíproca \\(\\vec{G}\\) cumple que \\(e^{{\\rm i} \\vec{G}\\cdot \\vec{R}}=1\\) donde \\(\\vec{R}\\) son los puntos de la red real.\n\n\n\nNotamos que los puntos \\(\\vec{G}\\) que cumplen la definición tienen dimensiones de \\[\n[\\vec{G}] = \\frac{1}{\\text{longitud}}\\,,\n\\] es decir las dimensiones recíprocas de la red \\(\\vec{R}\\), \\[\n[\\vec{R}]= \\text{longitud}\\,.\n\\]\nCon el fin de determinar los puntos de la red recíproca, \\(\\vec{G}\\) consideramos las siguientes dos suposiciones\n\nLos puntos \\(\\{ \\vec{G} \\}\\) forman una red, entonces podemos escribirlos como una combinación lineal de coeficientes enteros de vectores linealmente independientes.\n\n\\[\n\\vec{G}=m_1\\vec{b}_1+m_2\\vec{b}_2\n\\]\n\nLos vectores base de la red recíproca cumplen que\n\n\\[\n\\vec{a}_i\\cdot \\vec{b}_j = 2\\pi \\delta_{ij}\n\\] donde \\(\\vec{a}_i\\) son los vectores base de la red \\(\\{\\vec{R}\\}\\).\nIdentificamos que podemos escribir la relación previa de forma ordenada como matriz\n\\[\n\\left[\n\\begin{array}{cc}\n\\vec{a}_1\\cdot \\vec{b}_1 & \\vec{a}_1\\cdot \\vec{b}_2  \\\\\n\\vec{a}_2\\cdot \\vec{b}_1 & \\vec{a}_2\\cdot \\vec{b}_2\n\\end{array}\n\\right]=\\left[\n\\begin{array}{cc}\n2\\pi & 0 \\\\\n0 & 2\\pi \\\\  \n\\end{array}\n\\right]\n\\] El lado izquierdo podemos escribirlo como el producto de dos matrices\n\\[\n\\left[\n\\begin{array}{c}\n\\qquad \\vec{a}_1 \\qquad \\\\\n------\\\\\n\\qquad \\vec{a}_2 \\qquad \\\\\n\\end{array}\n\\right]\\left[\n\\begin{array}{cc}\n&|\\\\\n\\vec{b}_1&|&\\vec{b}_2\\\\\n&|\n\\end{array}\n\\right]=\\left[\n\\begin{array}{cc}\n2\\pi & 0 \\\\\n0 & 2\\pi\n\\end{array}\n\\right]\n\\] Definimos las matrices \\[\nA\\equiv \\left[\n\\begin{array}{c}\n\\qquad \\vec{a}_1 \\qquad \\\\\n------\\\\\n\\qquad \\vec{a}_2 \\qquad\n\\end{array}\n\\right]\n\\] y \\[\nB\\equiv \\left[\n\\begin{array}{cc}\n&|\\\\\n\\vec{b}_1&|&\\vec{b}_2\\\\\n&|\n\\end{array}\n\\right]\n\\] Por lo que,\n\\[\nAB = 2\\pi \\mathbb{I}\n\\] donde \\(\\mathbb{I}\\) es la matriz identidad.\nPor lo que, para determinar los vectores de la red recíproca,\n\\[\nB = 2\\pi A^{-1}\n\\]\n\n\n\nRed recíproca",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Estructura cristalina (cristal)</span>"
    ]
  },
  {
    "objectID": "2_grafeno.html#supercelda-de-grafeno",
    "href": "2_grafeno.html#supercelda-de-grafeno",
    "title": "3  Grafeno",
    "section": "",
    "text": "3.1.1 Zig-zag\n\n\nMostrar código\nribbon_zz = graphene_sc.cut_piece(4,1)\n(fig,ax) = ribbon_zz.visualize(0,1)\nax.set_title(\"Ribon (zig-zag)\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nfig.tight_layout()\n\n\n\n\n\n\n\n\nFigure 3.4: Liston Zig-zag\n\n\n\n\n\n\n\nMostrar código\nkpath = [[0],[1]]\n(k_vec,k_dist,k_node) = ribbon_zz.k_path(kpath, 100,report=False)\nEk = ribbon_zz.solve_all(k_vec)\n(fig,ax) = plt.subplots()\nax.plot(k_dist,Ek.T,c='k')\nax.set_xticks(k_node)\nax.set_ylabel(\"Ek\")\nax.set_xlabel(\"k\")\nfig.tight_layout()\n\n\n\n\n\n\n\n\nFigure 3.5: Bandas Zig-zag\n\n\n\n\n\n\n\n3.1.2 Armchair\n\n\nMostrar código\narmchair = graphene_sc.cut_piece(4,0)\n(fig,ax) = armchair.visualize(0,1)\nax.set_title(\"Ribon (armchair)\")\nax.set_xlabel(\"x\")\nax.set_ylabel(\"y\")\nfig.tight_layout()\n\n\n\n\n\n\n\n\nFigure 3.6: Liston Armchair\n\n\n\n\n\n\n\nMostrar código\nkpath = [[0],[1]]\n(k_vec,k_dist,k_node) = armchair.k_path(kpath, 100,report=False)\nEk = armchair.solve_all(k_vec)\n(fig,ax) = plt.subplots()\nax.plot(k_dist,Ek.T,c='k')\nax.set_xticks(k_node)\nax.set_ylabel(\"Ek\")\nax.set_xlabel(\"k\")\nfig.tight_layout()\n\n\n\n\n\n\n\n\nFigure 3.7: Bandas armchair",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Grafeno</span>"
    ]
  },
  {
    "objectID": "3_haldane.html#diagrama-de-fases-paper-haldane",
    "href": "3_haldane.html#diagrama-de-fases-paper-haldane",
    "title": "4  Modelo de Haldane",
    "section": "4.2 Diagrama de fases (paper Haldane)",
    "text": "4.2 Diagrama de fases (paper Haldane)\n\n\n\nFases Haldane. Phase diagram of the spinless electron model with \\(|t_2/t_1|&lt;1/3\\).",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Modelo de Haldane</span>"
    ]
  },
  {
    "objectID": "3_haldane.html#supercelda",
    "href": "3_haldane.html#supercelda",
    "title": "4  Modelo de Haldane",
    "section": "4.3 Supercelda",
    "text": "4.3 Supercelda\n\n\nMostrar código\nsc = haldane.make_supercell([[1,0],[-1,2]])\n\nsc.visualize(0,1)\n\n\n\n\n\n\n\n\n\n\n4.3.1 Zig-zag\n\n\nMostrar código\nzigzag = sc.cut_piece(10,1)\n\nzigzag.visualize(0,1)\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nkpath = [[0],[1]]\n(k_vec,k_dist,k_node) = zigzag.k_path(kpath, 100,report=False)\nEk = zigzag.solve_all(k_vec)\n(fig,ax) = plt.subplots()\nax.plot(k_dist,Ek.T,c='k')\nax.set_xticks(k_node)\nax.set_ylabel(\"Ek\")\nax.set_xlabel(\"k\")\nfig.tight_layout()\n\n\n\n\n\n\n\n\nFigure 4.3: Bandas Zig-zag\n\n\n\n\n\n\n\n4.3.2 Armchair\n\n\nMostrar código\narmchair = sc.cut_piece(10,0)\n\narmchair.visualize(0,1)\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\nkpath = [[-0.5],[0.5]]\n(k_vec,k_dist,k_node) = armchair.k_path(kpath, 100,report=False)\nEk = armchair.solve_all(k_vec)\n(fig,ax) = plt.subplots()\nax.plot(k_dist,Ek.T,c='k')\nax.set_xticks(k_node)\nax.set_ylabel(\"Ek\")\nax.set_xlabel(\"k\")\nfig.tight_layout()\n\n\n\n\n\n\n\n\nFigure 4.4: Bandas armchair",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Modelo de Haldane</span>"
    ]
  },
  {
    "objectID": "3_haldane.html#relación-de-dispersión",
    "href": "3_haldane.html#relación-de-dispersión",
    "title": "4  Modelo de Haldane",
    "section": "4.4 Relación de dispersión",
    "text": "4.4 Relación de dispersión\n\n\nMostrar código\nnkp = 100\nkpts = haldane.k_uniform_mesh((nkp,nkp))\n\nEk,U = haldane.solve_all(kpts,eig_vectors=True)\n\nb1,b2 = haldane.get_lat()\nbvec  = array([b1,b2])\nKX,KY = dot( bvec, kpts.T  )\n\n# Con el fin de graficar\nKX = KX.reshape(nkp,nkp)\nKY = KY.reshape(nkp,nkp)\n\n\nEkband_0 = Ek[0].reshape(nkp,nkp)\nEkband_1 = Ek[1].reshape(nkp,nkp)\n\n\n\n\nMostrar código\nimport plotly.graph_objects as go\n\nDATA = [go.Surface(z=Ekband_0, x=KX, y=KY,showscale=False),\ngo.Surface(z=Ekband_1, x=KX, y=KY,showscale=False)]\n\nfig = go.Figure( data=DATA )\nfig.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Modelo de Haldane</span>"
    ]
  },
  {
    "objectID": "3_haldane.html#curvatura-de-berry",
    "href": "3_haldane.html#curvatura-de-berry",
    "title": "4  Modelo de Haldane",
    "section": "4.5 Curvatura de Berry",
    "text": "4.5 Curvatura de Berry\n\\[\\begin{align}\nF_{n,m} = -{\\rm arg}\\big\\{  {\\rm exp}\\big[-{\\rm i} \\big( &\\phi_{(n,m),(n+1,m)} \\\\+ &\\phi_{(n+1,m),(n+1,m+1)} \\\\\n+ &\\phi_{(n+1,m+1),(n,m+1)} \\\\\n+ &\\phi_{(n,m+1),(n,m)} \\big) \\big] \\big\\}\n\\end{align}\\]\n\\[\\begin{align}\nF_{n,m} = -{\\rm arg}\\big\\{  {\\rm exp}\\big[-{\\rm i} \\big( &\\langle u_{n,m} |u_{n+1,m}\\rangle \\\\\n+ &\\langle u_{n+1,m} |u_{n+1,m+1}\\rangle \\\\\n+ &\\langle u_{n+1,m+1} |u_{n,m+1}\\rangle\\\\\n+ &\\langle u_{n,m+1} |u_{n,m}\\rangle \\big) \\big] \\big\\}\n\\end{align}\\]\n\n\nMostrar código\nu0 = U[0].reshape(nkp,nkp,2)\nu1 = U[1].reshape(nkp,nkp,2)\n\nF = zeros((nkp-1,nkp-1),dtype=\"complex\")\nfor n in range(nkp-1):\n  for m in range(nkp-1):\n    F[n,m] = vdot(u0[n+0,m+0],u0[n+1,m+0]) \\\n            *vdot(u0[n+1,m+0],u0[n+1,m+1]) \\\n            *vdot(u0[n+1,m+1],u0[n+0,m+1]) \\\n            *vdot(u0[n+0,m+1],u0[n+0,m+0])\n\n\nG = zeros((nkp-1,nkp-1),dtype=\"complex\")\nfor n in range(nkp-1):\n  for m in range(nkp-1):\n    G[n,m] = vdot(u1[n+0,m+0],u1[n+1,m+0]) \\\n            *vdot(u1[n+1,m+0],u1[n+1,m+1]) \\\n            *vdot(u1[n+1,m+1],u1[n+0,m+1]) \\\n            *vdot(u1[n+0,m+1],u1[n+0,m+0])\n\n\n\n\nMostrar código\nkx_new = KX[:-1,:-1]\nky_new = KY[:-1,:-1]\nangF   = angle(F)\nangG   = angle(G)\n\n\nfig, ax = plt.subplots(figsize=(6,6))\nmaximo = abs(angF).max()\ndots = ax.scatter(kx_new, ky_new, c=angF, s=1,cmap=\"coolwarm\",vmin=-maximo,vmax=maximo) #,vmin=-pi,vmax=pi,cmap=\"coolwarm\")\n#ax.set_ylim( -Δky/2,Δky/2 )\n#ax.set_xlim( 0,Δky )\nax.set_xlabel(r\"$k_x$\")\nax.set_ylabel(r\"$k_y$\")\nfig.colorbar(dots)\n#plt.show()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Modelo de Haldane</span>"
    ]
  },
  {
    "objectID": "3_haldane.html#estados-de-borde",
    "href": "3_haldane.html#estados-de-borde",
    "title": "4  Modelo de Haldane",
    "section": "4.6 Estados de borde",
    "text": "4.6 Estados de borde\n\n\nMostrar código\nfin_model = zigzag.cut_piece(10,0)\n\n(evals,evecs) = fin_model.solve_all(eig_vectors=True)\n# Determinamos el índice del eigenestado de enmedio\nef = fin_model.get_num_orbitals()//2\n\n# Figura del eigenestado de enmedio\n# pythtb tiene una opción de visualizar la red y algún eigenestado\n(fig,ax) = fin_model.visualize( 0,1, eig_dr=evecs[ef,:], draw_hoppings=False)\n# Colocamos un título a la gráfica\nax.set_title(\"Estado de borde de una red finita sin condiciones periódicas\");\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\n(fig,ax) = fin_model.visualize( 0,1, eig_dr=evecs[ef-1,:], draw_hoppings=False)\n# Colocamos un título a la gráfica\nax.set_title(\"Estado de borde de una red finita sin condiciones periódicas\");",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Modelo de Haldane</span>"
    ]
  },
  {
    "objectID": "4_KaneMele.html",
    "href": "4_KaneMele.html",
    "title": "5  Modelo Kane-Mele",
    "section": "",
    "text": "5.1 Estructura de bandas\nMostrar código\nkpath = [[0,0],[2/3,1/3],[1/2,1/2],[1/3,2/3],[0,0]] # Gamma, K, M, K', Gamma\n\nλSO = 0.03\nM   = 0.3\nλR  = 0.0\n\ndef Gaps(model):\n  K_array=wf_array(model,[50,50])\n  gaps = K_array.solve_on_grid([0.,0.])\n  return gaps\n\ntb = KaneMele(λI=λSO,M=M,λR=λR)\nk_vec,k_dist,k_node = tb.k_path(kpath,501,report=False)\nEk,evec = tb.solve_all(k_vec,eig_vectors=True)\nG = Gaps(tb)\n\nsz = diag([1,1,-1,-1])\nSz = [ [ real(vdot(ev,dot(sz,ev))) for ev in evec[band]] for band in range(len(Ek)) ]\n\nfor i in range(len(Ek)):\n  scatter(k_dist,Ek[i],s=1,c=Sz[i],cmap='coolwarm', vmin=-1.1, vmax=1.1) \nplt.title(r\"Sin el parámetro Rashba\")\nxticks(k_node,[r\"$\\Gamma$\",r\"K\",r\"M\",r\"K'\",r\"$\\Gamma$\"])\ngrid(True)\ncolorbar(label=r'Valor medio de $S_z$, $\\langle S_z \\rangle$')\nplt.show()\nMostrar código\nkpath = [[0,0],[2/3,1/3],[1/2,1/2],[1/3,2/3],[0,0]] # Gamma, K, M, K', Gamma\nλSO = 0.03\nM   = 0.3\nλR  = 0.02\n\ndef Gaps(model):\n  K_array=wf_array(model,[50,50])\n  gaps = K_array.solve_on_grid([0.,0.])\n  return gaps\n\ntb = KaneMele(λI=λSO,M=M,λR=λR)\nk_vec,k_dist,k_node = tb.k_path(kpath,501,report=False)\nEk,evec = tb.solve_all(k_vec,eig_vectors=True)\nG = Gaps(tb)\n\nsz = diag([1,1,-1,-1])\nSz = [ [ real(vdot(ev,dot(sz,ev))) for ev in evec[band]] for band in range(len(Ek)) ]\n\nfor i in range(len(Ek)):\n  scatter(k_dist,Ek[i],s=1,c=Sz[i],cmap='coolwarm', vmin=-1.1, vmax=1.1) \nplt.title(r\"Efecto del parámetro Rashba\")\nxticks(k_node,[r\"$\\Gamma$\",r\"K\",r\"M\",r\"K'\",r\"$\\Gamma$\"])\ngrid(True)\ncolorbar(label=r'Valor medio de $S_z$, $\\langle S_z \\rangle$')\nplt.show()\nMostrar código\nfig,ax=plt.subplots(1,2,figsize=(6,3))\nL=10\nλSO=0.03 \nλR=0.02\nk = linspace(0.,1.,301)\n\nM=0.1\nKM_RibbonZZ=KaneMele(λI=λSO,M=M,λR=λR).cut_piece(L,0)\nEk,evec = KM_RibbonZZ.solve_all(k,eig_vectors=True)\nsz = diag(L*[1,1,-1,-1])\nSz = [ [ real(vdot(ev,dot(sz,ev))) for ev in evec[band]] for band in range(len(Ek)) ]\nfor i in range(len(Ek)):\n  sc=ax[0].scatter(k,Ek[i],s=1,c=Sz[i],cmap='coolwarm', vmin=-1.1, vmax=1.1) \nax[0].set_title(\"Fase QSH\")\nax[0].set_ylim(-1,1)\nax[0].grid(True)\n\nM=0.4\nKM_RibbonZZ=KaneMele(λI=λSO,M=M,λR=λR).cut_piece(L,0)\nEk,evec = KM_RibbonZZ.solve_all(k,eig_vectors=True)\nsz = diag(L*[1,1,-1,-1])\nSz = [ [ real(vdot(ev,dot(sz,ev))) for ev in evec[band]] for band in range(len(Ek)) ]\nfor i in range(len(Ek)):\n  sc=ax[1].scatter(k,Ek[i],s=1,c=Sz[i],cmap='coolwarm', vmin=-1.1, vmax=1.1) \nax[1].set_title(\"Fase aislante\")\nax[1].set_ylim(-1,1)\nax[1].grid(True)\n\nfig.colorbar(sc,label=r'$\\langle S_z \\rangle$')\nplt.show()",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modelo Kane-Mele</span>"
    ]
  },
  {
    "objectID": "4_KaneMele.html#invariante-topológico",
    "href": "4_KaneMele.html#invariante-topológico",
    "title": "5  Modelo Kane-Mele",
    "section": "5.2 Invariante topológico",
    "text": "5.2 Invariante topológico\n\\[\\begin{align}\nP(\\vec{k}) = {\\rm Pf} [ \\langle u_i(\\vec{k}) | \\Theta | u_j(\\vec{k}) \\rangle]\n\\end{align}\\]\ndonde \\({\\rm Pf}\\) es el Pfaffiano de una matriz antisimétrica, el cual cumple que\n\\[\\begin{align}\n{\\rm Pf}^2(A) = {\\rm det}(A)\\,,\n\\end{align}\\]\ny \\(\\Theta={\\rm i}(I\\otimes s_y)\\) es el operador de reversión temporal.\nEl número de pares de ceros es el invariante topológico \\(\\mathbb{Z}_2\\).\n\n\nMostrar código\ndef Pfaffian(model,k_vec):\n  Pf=[]\n  for k in k_vec:\n    Ek,evec = model.solve_one(k,eig_vectors=True)\n    nF = model._norb//2\n    σy=np.array([[0,-1j],[1j,0]])\n    sy = kron(σy,diag(nF*[1]))\n    T = np.array( [[ vdot(ev1,dot(-1j*sy,conj(ev2)) )  for ev1 in evec[Ek&lt;0]] for ev2 in evec[Ek&lt;0]] )\n    Pf.append(sqrt(det(T)))\n  Pf=np.array(Pf)\n  return Pf\n\ndef Pffafian_one(model):\n  def Pf(k):\n    Ek,evec = model.solve_one(k,eig_vectors=True)\n    nF = model._norb//2\n    σy=np.array([[0,-1j],[1j,0]])\n    sy = kron(σy,diag(nF*[1]))\n    T = np.array( [[ vdot(ev1,dot(-1j*sy,conj(ev2)) )  for ev1 in evec[Ek&lt;0]] for ev2 in evec[Ek&lt;0]] )\n    return sqrt(det(T))\n  return Pf\n\nkpts = [[0,0],[2/3,1/3],[1/2,1/2],[1/3,2/3],[0,0]]\nλSO= 0.03\nM=0.1\nλR=0.01 #0.1476\n\ndef Z2_inv(model,k_vec):\n  Z2=0\n  P = Pffafian_one(model)\n  for k in k_vec:\n    if abs(P(k))&lt;10e-15:\n      Z2+=1\n  return Z2\n\ntb=KaneMele(λI=λSO,M=M,λR=λR)\nk_vec,k_dist,k_node = tb.k_path(kpts,nk=501,report=False)\nz2=Z2_inv(tb,k_vec)\nPf=Pfaffian(tb,k_vec)\ntitle(r\"$\\mathbb{Z}_2$ invariant \"+f\"= {z2:.0f}\")\nplot(k_dist,abs(Pf),c='k')\nxticks(k_node,[r\"$\\Gamma$\",r\"K\",r\"M\",r\"K'\",r\"$\\Gamma$\"])\nplt.show()\n\n\n\n\n\n\n\n\nFigure 5.1: Invariante Z2. El número de pares de ceros es el invariante topológico Z2.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Modelo Kane-Mele</span>"
    ]
  },
  {
    "objectID": "5_HOTI.html",
    "href": "5_HOTI.html",
    "title": "6  Aislates topológicos de orden superior",
    "section": "",
    "text": "Mostrar código\nfrom pylab import *\nfrom pythtb import *\n\nmpl.rcParams['figure.figsize'] = (2.5,2.5)\n\nδ    = 1e-6\ncint = 1\ncext = 2\n\nlat  = [[1,0],[0,1]]\norb  = [[0,0],[0.5,0],[0,0.5],[0.5,0.5]]\n\nHOTI = tb_model(2, 2, lat, orb)\n\nHOTI.set_onsite( [δ, -δ, δ, -δ] )\n\nHOTI.set_hop(           cint, 0, 1, [ 0, 0])\nHOTI.set_hop(exp(1J*pi)*cint, 0, 2, [ 0, 0])\nHOTI.set_hop(           cint, 1, 3, [ 0, 0])\nHOTI.set_hop(           cint, 2, 3, [ 0, 0])\n\nHOTI.set_hop(           cext, 0, 1, [-1, 0])\nHOTI.set_hop(           cext, 0, 2, [ 0,-1])\nHOTI.set_hop(exp(1J*pi)*cext, 1, 3, [ 0,-1])\nHOTI.set_hop(           cext, 2, 3, [-1, 0])\n\n\n\n\nMostrar código\nNx,Ny = 4,4\nHOTI_slab     =      HOTI.cut_piece(Nx,0,glue_edgs=False)\nHOTI_square   = HOTI_slab.cut_piece(Ny,1,glue_edgs=False)\n(evals,evecs) = HOTI_square.solve_all(eig_vectors=True)\n\n\n\n\nMostrar código\nhlines(evals,xmin=0.1,xmax=0.2)\n\n\n\n\n\n\n\n\n\n\n\nMostrar código\ndef local_DOS_one_eigen(Ek,U,n):\n    S = array( [ conj(U[n,i])*U[n,i] for i in range(len(Ek)) ] )\n    return real(S)\n\n\n\n\nMostrar código\ned=HOTI_square.get_num_orbitals()//2-2\n(fig,ax)=HOTI_square.visualize(0,1,eig_dr=evecs[ed,:],draw_hoppings=True)\nax.set_title(\"E={0:.2e}\".format(evals[ed]))\nax.set_xlabel(\"x coordinate\")\nax.set_ylabel(\"y coordinate\")\nfig.tight_layout()",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Aislates topológicos de orden superior</span>"
    ]
  },
  {
    "objectID": "6_Wannier90.html",
    "href": "6_Wannier90.html",
    "title": "7  Wannier90",
    "section": "",
    "text": "Mostrar código\nfrom pythtb import * # import TB model class\nfrom pylab import *\n#import matplotlib.pyplot as plt\n\nmpl.rcParams['figure.figsize'] = (2.5,2.5)\n\nGR = w90(r\"grafeno-qe\",r\"grafenowan\")\n\nmy_model = GR.model(min_hopping_norm=0.01)\n\npath = [[2/3,1/3,0],[0,0,0],[0.5,0,0]]\n\nk_label=(r'$K$', r'$\\Gamma$',r'$M$')\n\n(k_vec,k_dist,k_node)=my_model.k_path(path,1001,report=False)\n\nevals=my_model.solve_all(k_vec)\n\n#my_model.display()\n\nfig, ax = plt.subplots()\nfor i in range(evals.shape[0]):\n    ax.plot(k_dist,evals[i],\"k-\")\nfor n in range(len(k_node)):\n    ax.axvline(x=k_node[n],linewidth=0.5, color='k')\n\nax.set_xlabel(\"Path in k-space\")\nax.set_ylabel(\"Band energy (eV)\")\nax.set_xlim(k_dist[0],k_dist[-1])\nax.set_xticks(k_node)\nax.set_xticklabels(k_label)\nfig.tight_layout()\n\n#fig.savefig(\"GR_quick.pdf\")\n\n# Save pythtb to a file",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Wannier90</span>"
    ]
  }
]